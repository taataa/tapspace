<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>CIELAB Color Explorer- Tapspace Demo</title>

  <!-- Mobile-friendly width settings. Disables default browser zooming
       features native gestures. -->
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- your custom styles -->
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    body {
      background: white;
      color: black;
    }
    .myspaceapp {
      background: white;
      height: 100%;
    }
    .affine-node {
      background-color: blue;
    }
    .color-plane .color-node {
      text-align: center;
      font-family: Georgia, serif;
      padding-top: 50px;
      font-size: 26px;
      color: white;
      cursor: pointer;
    }
    .color-plane.current .color-node {
      /* border: 1rem solid black; */
    }
    .color-plane .color-info {
      color: transparent;
      display: none;
      font-size: 10px;
      font-family: 'Courier New', monospace;
      line-height: 10px;
      text-align: center;
    }
    .color-plane.current .color-info {
      display: block;
    }
    .word-cielab { font-size: 28px; }
    .word-colorspace { font-size: 19px; line-height: 28px; }
    .word-explorer { font-size: 26px; }
  </style>
</head>
<body>
  <!-- A tapspace viewport -->
  <div id="tapspace" class="myspaceapp"></div>

  <!-- Import tapspace. -->
  <script src="../../../dist/tapspace.min.js"></script>
  <!-- script src="https://unpkg.com/tapspace@2.0.0-alpha.10/dist/tapspace.min.js"></script -->

  <!-- Your code -->
  <script>
    // Setup the tapspace viewport and the default layer for content.
    const viewport = tapspace.createView('#tapspace')
    viewport.zoomable()
    // Add a control for navigation
    const zoomControl = new tapspace.components.ZoomControl()
    viewport.addControl(zoomControl)
    zoomControl.match({
      source: zoomControl.atBottomLeft(),
      target: viewport.atBottomLeft().offset(16, -16)
    })

    const jitter = (mean) => {
      // Poisson process inter-arrival time to simulate natural lag.
      return -Math.log(1 - Math.random()) * mean
    }
    const limit = (n, min, max) => {
      return Math.min(max, Math.max(min, n))
    }
    const idToLab = (id) => {
      const tid = id.substring(1)
      return tid.split('').reduce((lab, char, i) => {
        const scale = Math.pow(0.618, i + 1)
        switch (char) {
          case 'd':
            return { l: lab.l - scale * 50, a: lab.a, b: lab.b }
          case 'a':
            return { l: lab.l, a: lab.a - scale * 125, b: lab.b }
          case 'b':
            return { l: lab.l, a: lab.a, b: lab.b - scale * 125 }
          case 'l':
            return { l: lab.l + scale * 50, a: lab.a, b: lab.b }
          case 'e':
            return { l: lab.l, a: lab.a + scale * 125, b: lab.b }
          case 'f':
            return { l: lab.l, a: lab.a, b: lab.b + scale * 125 }
          default:
            return labl
        }
      }, { l: 50, a: 0, b: 0 })
    }
    const labToColor = (lab) => {
      const l = limit(lab.l, 0, 100).toFixed(8)
      const a = limit(lab.a, -125, 125).toFixed(8)
      const b = limit(lab.b, -125, 125).toFixed(8)
      return `lab(${l} ${a} ${b})`
    }
    const labToText = (lab, precision) => {
      return '<span>' + [
        'L:' + lab.l.toFixed(precision),
        'a:' + lab.a.toFixed(precision),
        'b:' + lab.b.toFixed(precision),
      ].join(' ') + '</span>'
    }
    const idToText = (id) => {
      if (id === 'r') {
        return [
          '<span class="word-cielab">CIELAB</span>',
          '<span class="word-colorspace">Color Space</span>',
          '<span class="word-explorer">Explorer</span>'
        ].join('<br>')
      }
      return ''
    }

    const loader = new tapspace.loaders.TreeLoader({
      viewport: viewport,

      mapper: (superid, superspace, subid) => {
        const dir = Math.PI / 2
        const step = Math.PI / 3
        const sid = subid.substring(subid.length - 1)
        const i = 'dablef'.indexOf(sid)
        if (i < 0) return null
        return superspace.getBasis()
          .polarOffset(600, dir + step * i)
          .scaleBy(0.32, superspace.contentNode.atCenter())
      },

      tracker: (superid, superspace) => {
        return 'dablef'.split('').map(char => superid + char)
      },

      backtracker: (subid, subspace) => {
        return subid.substring(0, subid.length - 1) || null
      }
    })

    const firstId = 'r'
    const firstBasis = viewport.getBasisAt(viewport.atCenter().offset(-100, -100))
    loader.init(firstId, firstBasis)

    // On first open, ignite the driver.
    loader.once('open', (id) => {
      viewport.requestIdle()
    })

    const createColorPatch = (id) => {
      const plane = tapspace.createPlane()
      plane.addClass('color-plane')
      plane.setAnchor({ x: 100, y: 100 })

      const lab = idToLab(id)
      const color = labToColor(lab)
      const node = tapspace.createNode(100, color)
      node.addClass('color-node')
      node.element.title = 'id:' + id
      node.html(idToText(id))
      node.setParent(plane, {Â x: 100, y: 100 })
      node.tappable({ preventDefault: false })
      node.on('tap', () => {
        viewport.animateOnce({ duration: 800, easing: 'ease-out' })
        viewport.zoomTo(node, { margin: '38%' })
        // Clear text selections.
        window.getSelection().removeAllRanges()
      })
      node.setContentInput(false)

      const info = tapspace.createItem()
      info.addClass('color-info')
      info.setSize(80, 50)
      info.html(labToText(lab, 0))
      info.setParent(plane)
      info.matchPoint(info.atBottomMid(), node.atBottomMid())
      info.scaleBy(0.62, info.atBottomMid())

      plane.contentNode = node // easy way to reach
      plane.contentInfo = info // easy way to reach
      plane.spaceId = id

      return plane
    }

    loader.on('open', (id) => {
      setTimeout(() => {
        const node = createColorPatch(id)
        loader.open(id, node)
      }, jitter(50))
    })

    // Idle driver for the tree.
    viewport.on('idle', () => {
      console.log('idle')
      const spaces = viewport.getSpaces()

      // Remove all too small spaces immediately.
      // Do this to avoid singular inversions.
      const singulars = viewport.findSingular()
      singulars.forEach(space => {
        const spaceId = space.spaceId
        loader.removeSpace(spaceId)
      })

      // Find closest, our current location.
      const nearest = viewport.measureNearest(spaces, 2)
      const nearestSpaces = nearest.map(ne => ne.target)

      // Style the closest. Unstyle others.
      spaces.forEach(space => {
        if (nearestSpaces.includes(space)) {
          space.addClass('current')
          space.contentInfo.setContentInput('pointer')
        } else {
          space.removeClass('current')
          space.contentInfo.setContentInput(false)
        }
      })

      // Expand and prune the tree.
      const nearestIds = nearestSpaces.map(space => space.spaceId)
      loader.closeNeighbors(nearestIds, 4)
      nearestIds.forEach(id => {
        loader.openNeighbors(id, 3)
      })

      // Prevent viewport from getting too far from the current nodes.
      viewport.limitTo(nearestSpaces)
    })
  </script>
</body>
</html>
