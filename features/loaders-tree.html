<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Tree Loader - Tapspace Features</title>

  <!-- Mobile-friendly width settings. Disables default browser zooming
       features native gestures. -->
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- your custom styles -->
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    body {
      background: white;
      color: black;
    }
    header {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
      padding: 0em 1em;
    }
    .myspaceapp {
      background: white;
      height: 100%;
    }
    .tree-node {
      background: DodgerBlue;
    }
    .tree-node.current {
      border: 2px solid black;
      background: Crimson;
    }
  </style>
</head>
<body>
  <header>
    <h1>Tree Loader â€“ Tapspace Features</h1>
    <p>
      Recursive loading and unloading of content is necessary in order
      to explore huge masses of data. Otherwise web browsers would slow down
      to tar under the load of thousands of elements.
    </p>
  </header>

  <!-- A tapspace viewport -->
  <div id="tapspace" class="myspaceapp"></div>

  <!-- Import tapspace. -->
  <script src="../dist/tapspace.min.js"></script>

  <!-- Your code -->
  <script>
    // Setup the tapspace viewport and the default layer for content.
    const viewport = tapspace.createView('#tapspace')
    viewport.zoomable()

    const loader = new tapspace.loaders.TreeLoader({
      viewport: viewport,

      placeholder: function (id) {
        // Render placeholder
        const plane = tapspace.createPlane()
        const circle = tapspace.createCircle(10, 'gray')
        plane.addChild(circle, plane.at(15, 15))
        return plane
      },

      generator: function (id, data) {
        // Render content to replace the placeholder
        const item = tapspace.createCircle(15)
        item.addClass('tree-node')
        item.element.title = 'id:' + id

        item.data = data

        item.tappable({ preventDefault: false })
        item.on('tap', () => {
          loader.openNeighbors(id, 3)
        })

        return item
      },

      fetcher: function (id, callback) {
        // Async call to fetch data for the generator.
        setTimeout(() => {
          const responseData = {
            id: id,
            nodes: [
              { id: id + 'a', x: 100, y: 0 },
              { id: id + 'b', x: 60, y: 80 },
              { id: id + 'c', x: 60, y: -80 },
              { id: id + 'd', x: -60, y: -80 },
              { id: id + 'e', x: -100, y: 0 },
              { id: id + 'f', x: -60, y: 80 }
            ]
          }
          callback(null, responseData)
        }, 400)
      },

      tracker: function (parent) {
        // Get IDs of the children of the parent component.
        return parent.data.nodes.map(node => node.id)
      },

      mapper: function (parent, childId) {
        // Find basis for a child with respect to the parent.
        const data = parent.data.nodes.find(n => n.id === childId)

        if (data) {
          return parent.getBasis()
            .scaleBy(0.3, parent.atAnchor())
            .offset(data.x, data.y)
        }

        return null
      },

      backer: function (childId) {
        // Find parent id.
        if (childId.length <= 1) {
          return null
        }
        return childId.substring(0, childId.length - 1)
      }
    })

    const firstBasis = tapspace.geometry.Basis.fromPoints(
      viewport,
      viewport.atCenter(),
      viewport.atCenter().offset(1, 0)
    )

    loader.init('aaa', firstBasis, (err) => {
      if (err) {
        console.error(err)
        return
      }
    })

    viewport.on('idle', () => {
      const hyperspace = viewport.getHyperspace()
      const spaces = hyperspace.getChildren().filter((comp) => {
        return !comp.isPlaceholder
      })

      const metrics = viewport.measureMany(spaces).filter((measure) => {
        // Filter out and remove too small.
        if (measure.dilation * measure.dilation < tapspace.math.epsilon * 2) {
          console.log('Too small')
          const spaceId = measure.target.data.id
          loader.removeSpace(spaceId)

          return false
        }
        return true
      })

      const best = metrics.reduce((acc, metric) => {
        if (metric.visualDistance < acc.minDistance) {
          return {
            minDistance: metric.visualDistance,
            bestTarget: metric.target,
            secondTarget: acc.bestTarget
          }
        }
        return acc
      }, {
        minDistance: Infinity,
        bestTarget: null,
        secondTarget: null
      })

      const currentSpace = best.bestTarget
      const secondSpace = best.secondTarget

      spaces.forEach(space => {
        if (space !== currentSpace && space !== secondSpace) {
          space.removeClass('current')
        } else {
          space.addClass('current')
        }
      })

      if (currentSpace) {
        const currentId = currentSpace.data.id

        if (secondSpace) {
          const secondId = secondSpace.data.id
          loader.closeNeighbors([currentId, secondId], 5)
        } else {
          loader.closeNeighbors(currentId, 5)
        }

        loader.openNeighbors(currentId, 3)
        if (secondSpace) {
          const secondId = secondSpace.data.id
          loader.openNeighbors(secondId, 3)
        }
      }
    })

  </script>
</body>
</html>
