<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Tree Loader - Tapspace Features</title>

  <!-- Mobile-friendly width settings. Disables default browser zooming
       features native gestures. -->
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- your custom styles -->
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    body {
      background: white;
      color: black;
    }
    header {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
      padding: 0em 1em;
    }
    .myspaceapp {
      background: white;
      height: 100%;
    }
    .tree-node {
      background: DodgerBlue;
      text-align: center;
      padding: 4.3rem 4rem;
    }
    .tree-node.current {
      border: 1rem solid black;
      background: MistyRose;
      padding: 3.3rem 3rem;
    }
  </style>
</head>
<body>
  <!-- A tapspace viewport -->
  <div id="tapspace" class="myspaceapp"></div>

  <!-- Import tapspace. -->
  <script src="../dist/tapspace.min.js"></script>

  <!-- Your code -->
  <script>
    // Setup the tapspace viewport and the default layer for content.
    const viewport = tapspace.createView('#tapspace')
    viewport.zoomable()

    const loader = new tapspace.loaders.TreeLoader({
      viewport: viewport,

      placeholder: function (id) {
        // Render placeholder
        const plane = tapspace.createPlane()
        const circle = tapspace.createCircle(100, 'gray')
        plane.addChild(circle, plane.at(150, 150))
        return plane
      },

      generator: function (id, data) {
        // Render content to replace the placeholder
        const item = tapspace.createCircle(150)
        item.addClass('tree-node')
        item.element.title = 'id:' + id

        item.data = data
        item.element.style.fontSize = data.fontSize + 'px'
        item.html(data.content)

        item.tappable({ preventDefault: false })
        item.on('tap', () => {
          loader.openNeighbors(id, 3)
          window.getSelection().removeAllRanges()
        })
        item.setContentInput(false)

        return item
      },

      fetcher: function (id, callback) {
        // Async call to fetch data for the generator.
        // For the sake of demo, simulate a server response
        setTimeout(() => {
          let content = ''
          let fontSize = 16
          if (id === 'aaa') {
            content = '<div>Tree Loader<br>â€“<br>Tapspace.js Demo</div>'
            fontSize = 32
          } else if (id === 'aaac') {
            content = '<div>Recursive loading and unloading of content '
              + 'is necessary in order to explore huge masses of data. '
              + 'Otherwise web browsers would slow down to tar '
              + 'under the load of thousands of elements.</div>'
            fontSize = 16
          } else if (id === 'aaacf') {
            content = '<div>tapspace.loaders.TreeLoader is the class '
              + 'that drives '
              + 'the recursive construction and destruction of content. '
              + '<br><br>'
              + 'Think it as a sliding window or a dynamic subset for '
              + 'your tree of content.</div>'
            fontSize = 16
          }

          const responseData = {
            id: id,
            content: content,
            fontSize: fontSize,
            nodes: [
              { id: id + 'a', x: 1000, y: 0 },
              { id: id + 'b', x: 600, y: 800 },
              { id: id + 'c', x: 600, y: -800 },
              { id: id + 'd', x: -600, y: -800 },
              { id: id + 'e', x: -1000, y: 0 },
              { id: id + 'f', x: -600, y: 800 }
            ]
          }
          callback(null, responseData)
        }, 400)
      },

      tracker: function (parent) {
        // Get IDs of the children of the parent component.
        return parent.data.nodes.map(node => node.id)
      },

      mapper: function (parent, childId) {
        // Find basis for a child with respect to the parent.
        const data = parent.data.nodes.find(n => n.id === childId)

        if (data) {
          return parent.getBasis()
            .scaleBy(0.3, parent.atAnchor())
            .offset(data.x, data.y)
        }

        return null
      },

      backer: function (childId) {
        // Find parent id.
        if (childId.length <= 1) {
          return null
        }
        return childId.substring(0, childId.length - 1)
      }
    })

    const firstBasis = viewport.getBasisAt(
      viewport.atCenter().offset(-150, -170),
    )

    loader.init('aaa', firstBasis, (err, sid, space) => {
      if (err) {
        console.error(err)
        return
      }
    })

    viewport.on('idle', () => {
      const hyperspace = viewport.getHyperspace()
      const spaces = hyperspace.getChildren().filter((comp) => {
        // Skip placeholders
        if (comp.data && comp.data.id) {
          return true
        }
        return false
      })

      const metrics = viewport.measureMany(spaces)

      const best = metrics.reduce((acc, metric) => {
        if (metric.visualDistance < acc.minDistance) {
          return {
            minDistance: metric.visualDistance,
            bestTarget: metric.target,
            secondTarget: acc.bestTarget
          }
        }
        return acc
      }, {
        minDistance: Infinity,
        bestTarget: null,
        secondTarget: null
      })

      const currentSpace = best.bestTarget
      const secondSpace = best.secondTarget

      spaces.forEach(space => {
        if (space !== currentSpace && space !== secondSpace) {
          space.removeClass('current')
          space.setContentInput(false)
        } else {
          space.addClass('current')
          space.setContentInput('pointer')
        }
      })

      if (currentSpace) {
        const currentId = currentSpace.data.id

        if (secondSpace) {
          const secondId = secondSpace.data.id
          loader.closeNeighbors([currentId, secondId], 5)
        } else {
          loader.closeNeighbors(currentId, 5)
        }

        loader.openNeighbors(currentId, 3)
        if (secondSpace) {
          const secondId = secondSpace.data.id
          loader.openNeighbors(secondId, 3)
        }
      }
    })

  </script>
</body>
</html>
