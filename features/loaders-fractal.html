<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fractal Loader - Tapspace Features</title>

  <!-- Mobile-friendly width settings. Disables default browser zooming
       features native gestures. -->
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- your custom styles -->
  <style>
    body {
      background: black;
      color: grey;
    }
    .myspaceapp {
      background: white;
      height: 500px;
    }
    .mycomponent {
      background: white;
      color: black;
    }
    .mylabel {
      margin-top: 1rem;
      padding: 1rem;
      text-align: center;
      font-size: 2rem;
    }
    .fractal-node {
      padding: 20px;
      color: white;
      word-break: break-all;
    }
    .mycomponent.active {
      background: #EEE;
    }
  </style>
</head>
<body>
  <h1>Fractal loader â€“ Tapspace Features</h1>
  <p>
    Recursive loading and unloading of content is necessary in order
    to explore huge masses of data. Otherwise web browsers would slow down
    to tar under the load of thousands of elements.
  </p>

  <!-- A tapspace viewport -->
  <div id="tapspace" class="myspaceapp"></div>

  <!-- Import tapspace. -->
  <script src="../dist/tapspace.min.js"></script>

  <!-- Your code -->
  <script>
    // Setup the tapspace viewport and the default layer for content.
    // Make the viewport responsive
    const viewport = tapspace.createView('#tapspace')
    viewport.responsive().zoomable().setMeasureMode('none')
    const hyperspace = viewport.getHyperspace()

    const size = 50
    const unit = size * 2
    const zunit = unit / 2
    const scaleStep = 0.32
    const groupOffset = { x: 0, y: 0, z: zunit }
    const offsets = [
      { x: unit, y: unit, z: zunit },
      { x: 1.2 * unit, y: 0, z: zunit }
      // { x: unit, y: -unit, z: zunit },
      // { x: -unit, y: 0, z: zunit }
    ]

    const create = (parent, group, depth, role, position, size, label) => {
      // Create a closed fractal node.
      //
      // Parameters:
      //   parent
      //     a fractal parent, not the parent in dom
      //   group
      //     the affine parent of the node to create, its space.
      //   depth
      //     an integer, to track depth
      //   role
      //     an integer, which children is this.
      //   position
      //     a Point, location in space
      //   size
      //     a number, circle radius represented on the group.
      //   label
      //     a string, text label
      //
      //
      console.log('create', label)

      const redness = depth * 40
      const color = 'rgb(' + redness + ', 0, 0)'

      const node = tapspace.createCircle(size, color)
      node.html(label)
      node.addClass('fractal-node')
      group.addChild(node, position)
      node.isFractal = true
      node.isAlive = true
      node.isOpen = false
      node.fractalDepth = depth
      node.fractalGroup = group
      node.fractalLabel = label
      node.fractalParent = parent
      node.fractalRole = role

      node.setContentInput(false)
      node.tappable({ preventDefault: false })
      node.on('tap', () => {
        console.log('node', node.fractalLabel, node)
        const measurement = viewport.measureOne(node)
        console.log('measurement', measurement)
      })

      return node
    }

    const open = (node) => {
      // Aka fractalTemplate OR openFractalKernel

      // Skip if removed or already open
      if (!node.isAlive) {
        return
      }
      if (node.isOpen) {
        return
      }
      console.log('open', node.fractalLabel)

      // Mark the node as opening/opened
      node.isOpen = true

      const origin = node.atCenter()
      const childDepth = node.fractalDepth + 1
      const labelPrefix = node.fractalLabel

      // Plane for children
      const contextScale = node.getScale().scaleBy(scaleStep)
      const subgroup = tapspace.createPlane()
      const subgroupOrigin = origin.addVector(groupOffset)
      viewport.addChild(subgroup, subgroupOrigin)
      subgroup.setScale(contextScale, subgroupOrigin)

      const p0 = origin.addVector(offsets[0])
      const l0 = labelPrefix + '0'
      const n0 = create(node, subgroup, childDepth, 0, p0, size, l0)

      const p1 = origin.addVector(offsets[1])
      const l1 = labelPrefix + '1'
      const n1 = create(node, subgroup, childDepth, 1, p1, size, l1)

      // const p2 = origin.offset(offsets[2])
      // const l2 = labelPrefix + '2'
      // const n2 = create(node, subgroup, childDepth, 2, p2, size, l2)
      //
      // const p3 = origin.offset(offsets[3])
      // const l3= labelPrefix + '3'
      // const n3 = create(node, subgroup, childDepth, 3, p3, size, l3)

      const fractalChildren = [n0, n1] // , n2, n3]
      node.fractalChildren = fractalChildren
      node.fractalSubgroup = subgroup
    }

    const reunite = (node) => {
      // Recreate parent for the node.
      console.log('reunion', node.fractalLabel)
    }

    const close = (node) => {
      // Remove children recursively

      if (!node.isAlive) {
        return
      }
      if (!node.fractalChildren || node.fractalChildren.length === 0) {
        // Unopenable or already closed
        return
      }
      console.log('close', node.fractalLabel)

      // Close and remove children recursively
      const kids = node.fractalChildren
      for (let i = 0; i < kids.length; i += 1) {
        remove(kids[i])
      }

      // Remove the plane for children after the children have closed,
      // but do not remove the node itself.
      node.fractalChildren = []
      node.fractalSubgroup.remove()
      node.fractalSubgroup = null

      node.isOpen = false
    }

    const retire = (node) => {
      // Remove a fractal node but keep its children.

      // Skip if removed or has parents
      if (!node.isAlive) {
        return
      }
      if (node.fractalParent) {
        return
      }
      console.log('retire', node.fractalLabel)

      // Remove from dom
      node.remove()
      // Cut references from children
      node.fractalChildren.forEach(child => {
        child.fractalParent = null
      })
      // Cut references to children
      node.fractalChildren = []
      node.fractalSubgroup = null // the subgroup remains in dom
      // Remove possibly empty group of the node.
      if (node.fractalGroup.isLeaf()) {
        node.fractalGroup.remove()
      }
      // Mark as dead
      node.isAlive = false
    }

    const remove = (node) => {
      // Remove a fractal node and all its children.

      // Skip removed
      if (!node.isAlive) {
        return
      }
      console.log('remove', node.fractalLabel)

      // Ensure closed
      if (node.isOpen) {
        close(node)
      }

      // Remove from dom
      node.remove()

      // Remove the group from dom if empty.
      if (node.fractalGroup.isLeaf()) {
        node.fractalGroup.remove()
      }

      // Mark as dead
      node.isAlive = false
    }

    const rootParent = null
    const rootGroup = tapspace.createPlane()
    viewport.addChild(rootGroup)
    const rootDepth = 0
    const rootRole = 0
    const rootOrigin = viewport.atAnchor()
    const rootSize = size
    const rootLabel = '0'
    const root = create(
      rootParent, rootGroup, rootDepth, rootRole,
      rootOrigin, rootSize, rootLabel
    )

    // Center viewport to content
    viewport.translateTo(hyperspace.atNorm(0.5, 0.5, 0))

    // Debug helper
    const logMeasure = (measure) => {
      const node = measure.plane
      console.log('measure ' + node.fractalLabel + ':',
        'area', measure.areaRatio.toFixed(5),
        'dist', measure.distancePx.toFixed(2)
      )
    }

    // Hiding and opening logic
    const MIN_AREA = 0.001 // smallest item
    const MIN_OPEN_AREA = 0.01 // closed items smaller than this
    const MAX_OPEN_AREA = 1 // closed items larger than this
    const MAX_AREA = 2 // largest item
    const MAX_OPEN_DISTANCE = 200
    const MAX_DISTANCE = 500

    viewport.on('idle', () => {
      console.log('idle')

      console.log('layers:')
      const spaces = hyperspace.getChildren()
      spaces.map((space) => {
        const numNodes = space.getChildren().length
        console.log(space.tran, 'with', numNodes, 'children')
      })
      viewport.rescale()

      // TODO allow measureAll to take a filter.
      const measures = viewport.measureAll().filter((measure) => {
        return measure.plane.isFractal
      })

      console.log('measured', measures.length, 'fractal nodes')

      const nodesToOpen = []
      const nodesToClose = []
      const nodesToRetire = []
      const nodesToRemove = []
      const nodesToReunite = []

      measures.forEach(measure => {
        const fractalNode = measure.plane

        if (!fractalNode.isAlive) {
          // Already removed during this iteration
          console.log('dead measure', fractalNode.fractalLabel)
          return
        }

        logMeasure(measure)

        const area = measure.areaRatio // Normalized area per viewport area
        const dist = measure.distancePx // Normlzd dist per viewport diagonal

        if (fractalNode.isOpen) {
          if (measure.visible) {
            // Node is open and within viewport
            if (area < MIN_AREA) {
              // Too far away, remove it and its children.
              nodesToRemove.push(fractalNode)
            } else if (area < MIN_OPEN_AREA) {
              // Far away, close the node
              nodesToClose.push(fractalNode)
              // Ensure parent exists
              nodesToReunite.push(fractalNode)
            } else if (area < MAX_OPEN_AREA) {
              // Keep open. Ensure parent exists.
              nodesToReunite.push(fractalNode)
            } else if (area < MAX_AREA) {
              // Large. Keep open.
            } else {
              // Too large. Remove but keep children.
              nodesToRetire.push(fractalNode)
            }
          } else {
            // Node is open but outside viewport.
            if (dist < MAX_OPEN_DISTANCE) {
              // Keep open
            } else if (dist < MAX_DISTANCE) {
              nodesToRetire.push(fractalNode)
            } else {
              nodesToRetire.push(fractalNode)
            }
          }
        } else {
          // Is closed, no children.
          if (measure.visible) {
            // Node is closed and within viewport
            if (area < MIN_AREA) {
              // Too small, remove it and children
              nodesToRemove.push(fractalNode)
            } else if (area < MIN_OPEN_AREA) {
              // Keep closed, ensure parent exists
              nodesToReunite.push(fractalNode)
            } else if (area < MAX_OPEN_AREA) {
              // Ensure parent exists
              nodesToOpen.push(fractalNode)
              nodesToReunite.push(fractalNode)
            } else if (area < MAX_AREA) {
              // Keep open
              nodesToOpen.push(fractalNode)
            } else {
              // Too large. Remove but keep children.
              nodesToRetire.push(fractalNode)
            }
          } else {
            // Node is closed and outside viewport.
            if (dist < MAX_OPEN_DISTANCE) {
              // Keep closed
            } else if (dist < MAX_DISTANCE) {
              // Keep closed
            } else {
              nodesToRemove.push(fractalNode)
            }
          }
        }
      })

      nodesToRemove.forEach(remove)
      nodesToClose.forEach(close)
      nodesToRetire.forEach(retire)
      nodesToOpen.forEach(open)
      nodesToReunite.forEach(reunite)
    })
  </script>
</body>
</html>
