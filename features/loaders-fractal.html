<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fractal Loader - Tapspace Features</title>

  <!-- Mobile-friendly width settings. Disables default browser zooming
       features native gestures. -->
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- your custom styles -->
  <style>
    body {
      background: black;
      color: grey;
    }
    .myspaceapp {
      background: white;
      height: 500px;
    }
    .mycomponent {
      background: white;
      color: black;
    }
    .mylabel {
      margin-top: 1rem;
      padding: 1rem;
      text-align: center;
      font-size: 2rem;
    }
    .fractal-node {
      padding: 20px;
      color: white;
      word-break: break-all;
    }
    .mycomponent.active {
      background: #EEE;
    }
  </style>
</head>
<body>
  <h1>Fractal loader â€“ Tapspace Features</h1>
  <p>
    Recursive loading and unloading of content is necessary in order
    to explore huge masses of data. Otherwise web browsers would slow down
    to tar under the load of thousands of elements.
  </p>

  <!-- A tapspace viewport -->
  <div id="tapspace" class="myspaceapp"></div>

  <!-- Import tapspace. -->
  <script src="../dist/tapspace.min.js"></script>

  <!-- Your code -->
  <script>
    // Setup the tapspace viewport and the default layer for content.
    // Make the viewport responsive
    const viewport = tapspace.createView('#tapspace')
    viewport.responsive().zoomable().setMeasureMode('none')
    const hyperspace = viewport.getHyperspace()

    const create = (group, depth, position, size, color, label) => {
      // Create a closed fractal node.
      console.log('create', label)

      const node = tapspace.createCircle(size, color)
      node.html(label)
      node.addClass('fractal-node')
      group.addChild(node, position)
      node.isFractal = true
      node.isAlive = true
      node.isOpen = false
      node.fractalGroup = group
      node.fractalDepth = depth
      node.fractalLabel = label

      node.setContentInput(false)
      node.tappable({ preventDefault: false })
      node.on('tap', () => {
        console.log('node', node.fractalLabel, node)
        const measurement = viewport.measureOne(node)
        console.log('measurement', measurement)
      })

      return node
    }

    const open = (node) => {
      // Aka fractalTemplate OR openFractalKernel
      console.log('open', node.fractalLabel)

      // Skip if already open
      if (node.isOpen) {
        return []
      }

      // Mark the node as opening/opened
      node.isOpen = true

      const size = 50
      const origin = node.atCenter()
      const unit = size * 2
      const zunit = unit / 2
      const childDepth = node.fractalDepth + 1
      const labelPrefix = node.fractalLabel

      // Plane for children
      const contextScale = node.getScale().scaleBy(0.32)
      const subgroup = tapspace.createPlane()
      const subgroupOrigin = origin.offset(0, 0, zunit)
      hyperspace.addChild(subgroup, subgroupOrigin)
      subgroup.setScale(contextScale, subgroupOrigin)

      const red = childDepth * 40
      const color = 'rgb(' + red + ', 0, 0)'

      const p0 = origin.offset(unit, unit)
      const l0 = labelPrefix + '0'
      const n0 = create(subgroup, childDepth, p0, size, color, l0)

      const p1 = origin.offset(1.2 * unit, 0)
      const l1 = labelPrefix + '1'
      const n1 = create(subgroup, childDepth, p1, size, color, l1)

      // const p2 = origin.offset(unit, -unit)
      // const l2 = labelPrefix + '2'
      // const n2 = create(subgroup, childDepth, p2, size, color, l2)
      //
      // const p3 = origin.offset(-unit, 0)
      // const l3= labelPrefix + '3'
      // const n3 = create(subgroup, childDepth, p3, size, color, l3)

      const fractalChildren = [n0, n1] // , n2, n3]
      node.fractalChildren = fractalChildren
      node.fractalSubgroup = subgroup

      return fractalChildren
    }

    const reunion = (node) => {
      // Recreate parent for the node.
      console.log('reunion', node.fractalLabel)
    }

    const close = (node) => {
      // Remove children recursively
      console.log('close', node.fractalLabel)

      if (!node.fractalChildren || node.fractalChildren.length === 0) {
        // Unopenable or already closed
        return
      }

      // Close and remove children recursively
      const kids = node.fractalChildren
      for (let i = 0; i < kids.length; i += 1) {
        remove(kids[i])
      }

      // Remove the plane for children after the children have closed,
      // but do not remove the node itself.
      node.fractalChildren = []
      node.fractalSubgroup.remove()
      node.fractalSubgroup = null

      node.isOpen = false
    }

    const retire = (node) => {
      // Remove a fractal node but keep its children.
      console.log('retire', node.fractalLabel)

      // Remove from dom
      node.remove()
      // Cut references to children
      node.fractalChildren = []
      node.fractalSubgroup = null // the subgroup remains in dom
      // Mark as dead
      node.isAlive = false
    }

    const remove = (node) => {
      // Remove a fractal node and all its children.
      console.log('remove', node.fractalLabel)

      // Skip removed
      if (!node.isAlive) {
        return
      }

      // Ensure closed
      if (node.isOpen) {
        close(node)
      }

      // Remove from dom
      node.remove()

      // Mark as dead
      node.isAlive = false
    }

    const rootPlane = tapspace.createPlane()
    hyperspace.addChild(rootPlane)
    const root = create(rootPlane, 0, viewport.atAnchor(), 50, 'black', '0')

    // Initially open two levels of nodes
    let allNodes = []
    let successors = [root]
    for (let i = 0; i < 2; i += 1) {
      // Capture nodes
      allNodes = allNodes.concat(successors)
      // Open the nodes
      const opened = successors.map((succ) => {
        return open(succ)
      }).reduce((acc, succs) => {
        return acc.concat(succs)
      }, [])
      // Reinsert
      successors = opened
    }

    // Center viewport to content
    viewport.translateTo(hyperspace.atNorm(0.5, 0.5, 0))

    // Debug helper
    const logMeasure = (measure) => {
      const node = measure.plane
      console.log(node.fractalLabel + ':',
        'area', measure.areaRatio.toFixed(5),
        'dist', measure.distancePx.toFixed(2)
      )
    }

    // Hiding and opening logic
    const MIN_AREA = 0.001 // smallest item
    const MIN_OPEN_AREA = 0.01 // closed items smaller than this
    const MAX_OPEN_AREA = 1 // closed items larger than this
    const MAX_AREA = 2 // largest item
    const MAX_OPEN_DISTANCE = 200
    const MAX_DISTANCE = 500

    viewport.on('idle', () => {
      console.log('idle')

      const spaces = hyperspace.getChildren()
      spaces.map((space) => {
        console.log(space.tran)
      })
      hyperspace.rescale()

      // TODO allow measureAll to take a filter.
      const measures = viewport.measureAll().filter((measure) => {
        return measure.plane.isFractal
      })

      console.log('measured', measures.length, 'fractal nodes')

      measures.forEach(measure => {
        const fractalNode = measure.plane

        if (!fractalNode.isAlive) {
          // Already removed during this iteration
          console.log('dead measure', fractalNode.fractalLabel)
          return
        }

        logMeasure(measure)

        const area = measure.areaRatio // Normalized area per viewport area
        const dist = measure.distancePx // Normlzd dist per viewport diagonal

        if (fractalNode.isOpen) {
          if (measure.visible) {
            // Node is open and within viewport
            if (area < MIN_AREA) {
              // Too far away, remove it and its children.
              remove(fractalNode)
            } else if (area < MIN_OPEN_AREA) {
              // Far away, close the node
              close(fractalNode)
            } else if (area < MAX_OPEN_AREA) {
              // Keep open
            } else if (area < MAX_AREA) {
              // Large. Keep open.
            } else {
              // Too large. Remove but keep children.
              retire(fractalNode)
            }
          } else {
            // Node is open but outside viewport.
            if (dist < MAX_OPEN_DISTANCE) {
              // Keep open
            } else if (dist < MAX_DISTANCE) {
              retire(fractalNode)
            } else {
              remove(fractalNode)
            }
          }
        } else {
          // Is closed, no children.
          if (measure.visible) {
            // Node is closed and within viewport
            if (area < MIN_AREA) {
              // Too small, remove it and children
              remove(fractalNode)
            } else if (area < MIN_OPEN_AREA) {
              // Keep closed
            } else if (area < MAX_OPEN_AREA) {
              open(fractalNode)
            } else if (area < MAX_AREA) {
              // Keep open
              open(fractalNode)
            } else {
              // Too large. Remove but keep children.
              retire(fractalNode)
            }
          } else {
            // Node is closed and outside viewport.
            if (dist < MAX_OPEN_DISTANCE) {
              // Keep closed
            } else if (dist < MAX_DISTANCE) {
              // Keep closed
            } else {
              remove(fractalNode)
            }
          }
        }
      })
    })

    // DEBUG
    console.log('nodes:', allNodes.length)
  </script>
</body>
</html>
