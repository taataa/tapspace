<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fractal Loader - Tapspace Features</title>

  <!-- Mobile-friendly width settings. Disables default browser zooming
       features native gestures. -->
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- your custom styles -->
  <style>
    body {
      background: black;
      color: grey;
    }
    .myspaceapp {
      background: white;
      height: 500px;
    }
    .mycomponent {
      background: white;
      color: black;
    }
    .mylabel {
      margin-top: 1rem;
      padding: 1rem;
      text-align: center;
      font-size: 2rem;
    }
    .mycomponent.active {
      background: #EEE;
    }
  </style>
</head>
<body>
  <h1>Fractal loader â€“ Tapspace Features</h1>
  <p>
    Recursive loading and unloading of content is necessary in order
    to explore huge masses of data. Otherwise web browsers would slow down
    to tar under the load of thousands of elements.
  </p>

  <!-- A tapspace viewport -->
  <div id="tapspace" class="myspaceapp"></div>

  <!-- Import tapspace. -->
  <script src="../dist/tapspace.min.js"></script>

  <!-- Your code -->
  <script>
    // Setup the tapspace viewport and the default layer for content.
    // Make the viewport responsive
    const viewport = tapspace.createView('#tapspace')
    viewport.responsive().zoomable().setMeasureMode('none')
    const space = tapspace.createSpace()
    viewport.addChild(space)

    const create = (basis, depth, position, scale, size, color) => {
      // Create a closed fractal node.

      const node = tapspace.createCircle(size, color)
      basis.addChild(node, position)
      node.setScale(scale)
      node.isFractal = true
      node.isAlive = true
      node.isOpen = false
      node.fractalDepth = depth

      return node
    }

    const open = (node, basis) => {
      // Aka fractalTemplate OR openFractalKernel
      console.log('open', node)

      // Mark the node as opening/opened
      node.isOpen = true

      const size = 50
      const scale = node.getScale().scaleBy(0.32)
      const origin = node.atCenter()
      const unit = size * 2
      const zunit = unit / 2
      const childDepth = node.fractalDepth + 1

      // Plane for children
      const plane = tapspace.createPlane()
      basis.addChild(plane, origin.offset(0, 0, zunit))

      const red = childDepth * 40
      const color = 'rgb(' + red + ', 0, 0)'

      const p0 = origin.offset(unit, unit)
      const n0 = create(plane, childDepth, p0, scale, size, color)

      const p1 = origin.offset(1.2 * unit, 0)
      const n1 = create(plane, childDepth, p1, scale, size, color)

      const p2 = origin.offset(unit, -unit)
      const n2 = create(plane, childDepth, p2, scale, size, color)

      const p3 = origin.offset(-unit, 0)
      const n3 = create(plane, childDepth, p3, scale, size, color)

      const fractalChildren = [n0, n1, n2, n3]
      node.fractalChildren = fractalChildren
      node.fractalPlane = plane

      return fractalChildren
    }

    const close = (node) => {
      // Remove children recursively
      console.log('close', node)

      if (!node.fractalChildren || node.fractalChildren.length === 0) {
        // Unopenable or already closed
        return
      }

      // Close and remove children recursively
      const kids = node.fractalChildren
      for (let i = 0; i < kids.length; i += 1) {
        remove(kids[i])
      }

      // Remove the plane for children after the children have closed,
      // but do not remove the node itself.
      node.fractalChildren = []
      node.fractalPlane.remove()

      node.isOpen = false
    }

    const retire = (node) => {
      // Remove a fractal node but keep its children.
      console.log('retire', node)

      // Remove from dom
      node.remove()
      // Cut references to children
      node.fractalChildren = []
      node.fractalPlane = null // the plane remains in dom
      // Mark as dead
      node.isAlive = false
    }

    const remove = (node) => {
      // Remove a fractal node and all its children.
      console.log('remove', node)

      // Skip removed
      if (!node.isAlive) {
        return
      }

      // Ensure closed
      if (node.isOpen) {
        close(node)
      }

      // Remove from dom
      node.remove()

      // Mark as dead
      node.isAlive = false
    }

    const root = create(space, 0, viewport.atAnchor(), 1, 50, 'black')

    // Initially open two levels of nodes
    let allNodes = []
    let successors = [root]
    for (let i = 0; i < 2; i += 1) {
      // Capture nodes
      allNodes = allNodes.concat(successors)
      // Open the nodes
      const opened = successors.map((succ) => {
        return open(succ, space)
      }).reduce((acc, succs) => {
        return acc.concat(succs)
      }, [])
      // Reinsert
      successors = opened
    }

    // Center viewport to content
    viewport.translateTo(space.atNorm(0.5, 0.5, 0))

    // Hiding and opening logic
    const MIN_AREA = 0.001 // smallest item
    const MIN_OPEN_AREA = 0.01 // closed items smaller than this
    const MAX_OPEN_AREA = 1 // closed items larger than this
    const MAX_AREA = 2 // largest item
    const MAX_OPEN_DISTANCE = 200
    const MAX_DISTANCE = 500

    viewport.on('idle', () => {
      console.log('idle')

      // TODO allow measurePlanes to take a filter.
      const measures = viewport.measurePlanes().filter((measure) => {
        return measure.plane.isFractal
      })

      measures.forEach(measure => {
        const fractalNode = measure.plane

        if (!fractalNode.isAlive) {
          // Already removed during this iteration
          return
        }

        const area = measure.areaRatio // Normalized area per viewport area
        const dist = measure.distancePx // Normlzd dist per viewport diagonal

        if (fractalNode.isOpen) {
          if (measure.visible) {
            // Node is open and within viewport
            if (area < MIN_AREA) {
              console.log('area', area)
              // Too far away, remove it and its children.
              remove(fractalNode)
            } else if (area < MIN_OPEN_AREA) {
              console.log('area', area)
              // Far away, close the node
              close(fractalNode)
            } else if (area < MAX_OPEN_AREA) {
              // Keep open
            } else if (area < MAX_AREA) {
              console.log('area', area)
              // Large. Keep open.
              retire(fractalNode)
            } else {
              console.log('area', area)
              // Too large. Remove but keep children.
              retire(fractalNode)
            }
          } else {
            // Node is open but outside viewport.
            if (dist < MAX_OPEN_DISTANCE) {
              // Keep open
            } else if (dist < MAX_DISTANCE) {
              console.log('area', area)
              close(fractalNode)
            } else {
              console.log('area', area)
              remove(fractalNode)
            }
          }
        } else {
          // Is closed, no children.
          if (measure.visible) {
            // Node is closed and within viewport
            if (area < MIN_AREA) {
              console.log('area', area)
              // Too small, remove it and children
              remove(fractalNode)
            } else if (area < MIN_OPEN_AREA) {
              // Keep closed
            } else if (area < MAX_OPEN_AREA) {
              console.log('area', area)
              open(fractalNode, space)
            } else if (area < MAX_AREA) {
              // Keep closed
            } else {
              console.log('area', area)
              // Too large. Remove but keep children.
              retire(fractalNode)
            }
          } else {
            // Node is closed and outside viewport.
            if (dist < MAX_OPEN_DISTANCE) {
              // Keep closed
            } else if (dist < MAX_DISTANCE) {
              // Keep closed
            } else {
              console.log('area', area)
              remove(fractalNode)
            }
          }
        }
      })
    })

    // DEBUG
    console.log('nodes:', allNodes.length)
  </script>
</body>
</html>
