<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fractal Loader - Tapspace Features</title>

  <!-- Mobile-friendly width settings. Disables default browser zooming
       features native gestures. -->
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- your custom styles -->
  <style>
    body {
      background: black;
      color: grey;
    }
    .myspaceapp {
      background: white;
      height: 500px;
    }
    .mycomponent {
      background: white;
      color: black;
    }
    .mylabel {
      margin-top: 1rem;
      padding: 1rem;
      text-align: center;
      font-size: 2rem;
    }
    .fractal-node {
      padding: 20px;
      color: white;
      word-break: break-all;
    }
    .mycomponent.active {
      background: #EEE;
    }
  </style>
</head>
<body>
  <h1>Fractal loader â€“ Tapspace Features</h1>
  <p>
    Recursive loading and unloading of content is necessary in order
    to explore huge masses of data. Otherwise web browsers would slow down
    to tar under the load of thousands of elements.
  </p>

  <!-- A tapspace viewport -->
  <div id="tapspace" class="myspaceapp"></div>

  <!-- Import tapspace. -->
  <script src="../dist/tapspace.min.js"></script>

  <!-- Your code -->
  <script>
    // Setup the tapspace viewport and the default layer for content.
    // Make the viewport responsive
    const viewport = tapspace.createView('#tapspace')
    viewport.responsive().zoomable().setMeasureMode('none')

    const tracker = (parents) => {
      // Find bases and IDs of the children of the given parents.
      //
      // Parameters:
      //   parents
      //     an array of track, where each track is { id, basis }
      //
      // Return
      //   an array of track, the tracks of children
      //

      // Debug
      if (parents.length < 1) {
        const err = new Error('Tracker called with empty parent tracks.')
        return callback(null, [])
      }

      // Single-parent tracker.
      const id = parents[0].id
      const basis = parents[0].basis

      // Children
      const tracks = [
        {
          id: id + '0',
          basis: basis.scaleBy(0.333).translateBy({ x: 200, y: 200, z: 50 })
        },
        {
          id: id + '1',
          basis: basis.scaleBy(0.333).translateBy({ x: 250, y: 0, z: 50 })
        },
        {
          id: id + '2',
          basis: basis.scaleBy(0.333).translateBy({ x: 200, y: -200, z: 50 })
        }
      ]

      return tracks
    }

    const backtracker = (children) => {
      // Find bases and IDs of parents of the given children.
      //
      // Parameters:
      //   children
      //     an array of track, where each track is { id, basis }
      //
      // Return
      //   an array of track, the parent tracks. Can be empty if no parents.
      //

      // Debug
      if (children.length < 1) {
        const err = new Error('Backtracker called without child tracks.')
        return callback(null, [])
      }

      // Single-parent backtracker
      const firstbornId = children[0].id
      const parentId = firstbornId.substring(0, firstbornId.length - 1)

      // Limit to root id
      if (parentId.length < 1) {
        return []
      }

      let parentBasis = null
      for (let i = 0; i < children.length; i += 1) {
        const id = children[i].id
        const basis = children[i].basis

        if (id === parentId + '0') {
          const vector = { x: -200, y: -200, z: -50 }
          parentBasis = basis.translateBy(vector).scaleBy(3)
          break
        }
        if (id === parentId + '1') {
          const vector = { x: -250, y: 0, z: -50 }
          parentBasis = basis.translateBy(vector).scaleBy(3)
          break
        }
        if (id === parentId + '2') {
          const vector = { x: -200, y: 200, z: -50 }
          parentBasis = basis.translateBy(vector).scaleBy(3)
          break
        }
      }

      const parentTrack = {
        id: parentId,
        basis: parentBasis
      }

      return [parentTrack]
    }

    const getDepth = (id) => {
      return id.length - 1
    }

    const getColor = (id) => {
      const d = getDepth(id)
      const redness = d * 40
      const color = 'rgb(' + redness + ', 0, 0)'
      return color
    }

    const generator = (ids, callback) => {
      // Create node components for IDs.
      // This can include asynchronic fetching of node data from backend.
      //
      const nodes = ids.map(id => {
        const size = 50
        const color = getColor(id)
        const node = tapspace.createCircle(size, color)
        node.html('' + id)
        node.addClass('fractal-node')

        return node
      })

      callback(null, nodes)
    }

    const initial = [{
      id: '0',
      basis: viewport.getBasis()
    }]

    const loader = new tapspace.loaders.FractalLoader({
      viewport: viewport,
      tracker: tracker,
      backtracker: backtracker,
      generator: generator,
      initial: initial
    })
  </script>
</body>
</html>
