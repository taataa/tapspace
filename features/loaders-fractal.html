<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fractal Loader - Tapspace Features</title>

  <!-- Mobile-friendly width settings. Disables default browser zooming
       features native gestures. -->
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- your custom styles -->
  <style>
    body {
      background: black;
      color: grey;
    }
    .myspaceapp {
      background: white;
      height: 500px;
    }
    .mycomponent {
      background: white;
      color: black;
    }
    .mylabel {
      margin-top: 1rem;
      padding: 1rem;
      text-align: center;
      font-size: 2rem;
    }
    .mycomponent.active {
      background: #EEE;
    }
  </style>
</head>
<body>
  <h1>Fractal loader â€“ Tapspace Features</h1>
  <p>
    Recursive loading and unloading of content is necessary in order
    to explore huge masses of data. Otherwise web browsers would slow down
    to tar under the load of thousands of elements.
  </p>

  <!-- A tapspace viewport -->
  <div id="tapspace" class="myspaceapp"></div>

  <!-- Import tapspace. -->
  <script src="../dist/tapspace.min.js"></script>

  <!-- Your code -->
  <script>
    // Setup the tapspace viewport and the default layer for content.
    // Make the viewport responsive
    const viewport = tapspace.createView('#tapspace')
    viewport.responsive().zoomable().setMeasureMode('none')
    const space = tapspace.createSpace()
    viewport.addChild(space)

    const create = (basis, depth, position, scale, size, color) => {
      // Create a closed fractal node.

      const node = tapspace.createCircle(size, color)
      basis.addChild(node, position)
      node.setScale(scale)
      node.isFractal = true
      node.isAlive = true
      node.isOpen = false
      node.fractalDepth = depth

      return node
    }

    const open = (node, basis) => {
      // OR fractalTemplate OR openFractalKernel
      console.log('open')

      // Mark the node as opening/opened
      node.isOpen = true

      const size = 50
      const scale = node.getScale().scaleBy(0.32)
      const origin = node.atCenter()
      const unit = size * 2
      const zunit = unit / 2
      const childDepth = node.fractalDepth + 1

      // Plane for children
      const plane = tapspace.createPlane()
      basis.addChild(plane, origin.offset(0, 0, zunit))

      const red = childDepth * 40
      const color = 'rgb(' + red + ', 0, 0)'

      const p0 = origin.offset(unit, unit)
      const n0 = create(plane, childDepth, p0, scale, size, color)

      const p1 = origin.offset(1.2 * unit, 0)
      const n1 = create(plane, childDepth, p1, scale, size, color)

      const p2 = origin.offset(unit, -unit)
      const n2 = create(plane, childDepth, p2, scale, size, color)

      const p3 = origin.offset(-unit, 0)
      const n3 = create(plane, childDepth, p3, scale, size, color)

      const fractalChildren = [n0, n1, n2, n3]
      node.fractalChildren = fractalChildren
      node.fractalPlane = plane

      return fractalChildren
    }

    const close = (node) => {
      if (!node.fractalChildren || node.fractalChildren.length === 0) {
        // Unopenable or already closed
        return
      }

      // Close and remove children recursively
      const kids = node.fractalChildren
      for (let i = 0; i < kids.length; i += 1) {
        remove(kids[i])
      }

      // Remove the plane for children after the children have closed,
      // but do not remove the node itself.
      node.fractalChildren = []
      node.fractalPlane.remove()

      node.isOpen = false
    }

    const retire = (node) => {
      // Remove a fractal node but keep its children.

      // Remove from dom
      fractalNode.remove()
      // Cut references to children
      fractalNode.fractalChildren = []
      fractalNode.fractalPlane = null // the plane remains in dom
      // Mark as dead
      fractalNode.isAlive = false
    }

    const remove = (node) => {
      // Remove a fractal node and all its children.

      // Skip removed
      if (!node.isAlive) {
        return
      }

      // Ensure closed
      if (node.isOpen) {
        close(node)
      }

      // Remove from dom
      node.remove()

      // Mark as dead
      node.isAlive = false
    }

    const root = create(space, 0, viewport.atAnchor(), 1, 50, 'black')

    // Initially open two levels of nodes
    let allNodes = []
    let successors = [root]
    for (let i = 0; i < 2; i += 1) {
      // Capture nodes
      allNodes = allNodes.concat(successors)
      // Open the nodes
      const opened = successors.map((succ) => {
        return open(succ, space)
      }).reduce((acc, succs) => {
        return acc.concat(succs)
      }, [])
      // Reinsert
      successors = opened
    }

    // Center viewport to content
    viewport.translateTo(space.atNorm(0.5, 0.5, 0))

    // Hiding and opening logic
    const HORIZON_DEPTH = 800
    const CLOSING_DEPTH = 500
    const OPENING_DEPTH = 200
    const CUTTING_DEPTH = -400
    viewport.on('idle', () => {
      console.log('idle')

      // TODO allow measurePlanes to take a filter.
      const measures = viewport.measurePlanes().filter((measure) => {
        return measure.plane.isFractal
      })

      measures.forEach(measure => {
        const fractalNode = measure.plane

        if (!fractalNode.isAlive) {
          // Already removed during this iteration
          return
        }

        const depthPx = measure.depthPx

        if (fractalNode.isOpen) {
          if (measure.visible) {
            // Node is open and within viewport
            if (depthPx > CLOSING_DEPTH) {
              // Too far away, close the node
              close(fractalNode)
            } else if (depthPx < CUTTING_DEPTH) {
              // Too large, remove but keep the children and their plane.
              retire(fractalNode)
            }
          } else {
            // Node is open but outside viewport.
            close(fractalNode)
          }
        } else {
          // Is closed, no children.
          if (measure.visible) {
            // Node is closed and within viewport
            if (depthPx < CUTTING_DEPTH) {
              // Too large.
              remove(fractalNode)
            } else if (depthPx > HORIZON_DEPTH) {
              // Too far away
              remove(fractalNode)
            } else if (depthPx > OPENING_DEPTH && depthPx < CLOSING_DEPTH) {
              // Suitable for opening
              open(fractalNode, space)
            }
          } else {
            // Node is closed and outside viewport.
            if (depthPx < CUTTING_DEPTH) {
              remove(fractalNode)
            } else if (depthPx > HORIZON_DEPTH) {
              remove(fractalNode)
            }
          }
        }
      })
    })

    // DEBUG
    console.log('nodes:', allNodes.length)
  </script>
</body>
</html>
