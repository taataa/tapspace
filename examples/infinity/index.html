<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Infinity - Tapspace Example</title>

  <!--
    Infinite zoomer

    In this example we implement infinite zooming into a picture.
  -->

  <style>
    html, body, #space {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: black;
      color: black;
      font-family: sans-serif;
    }

    #heading {
      padding: 0 1em 0 1em;
    }
    #heading h1 {
      font-size: 2.62em;
      margin: 0.38em 0 0 0;
    }
    #heading p {
      font-size: 1em;
      margin: 0.25em 0 0 0;
      text-align: right;
    }
    #heading a {
      color: black;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="space"></div>

  <script src="../assets/ghoulog.js"></script>
  <script src="https://unpkg.com/tapspace@1.3.0/dist/tapspace.min.js"></script>

  <script>
    var space = new tapspace.Space()
    var view = new tapspace.SpaceView(space)
    view.mount(document.getElementById('space'))

    var heading = new tapspace.SpaceHTML(
      '<div id="heading">' +
        '<h1>Infinity</h1>' +
        '<p>Powered by <a href="http://taataa.github.io/tapspace/">' +
        'Tapspace.js</a></p>' +
      '</div>'
    )

    tapspace.preload([
      '../assets/arrowheads.png'
    ], function (err, imgs) {
      if (err) { throw err }

      var i, si, prev

      // Compute the relative position of a next item.
      var PHI = (1 + Math.sqrt(5)) / 2
      var PHI2 = PHI * PHI
      var PHI3 = PHI2 * PHI
      var A = 1 - 1 / PHI + 1 / PHI2 - 1 / PHI3
      var B = 1 - 1 / PHI + 1 / PHI2

      // The chainWindow is a window to a full chain.
      // The chainWindow contains only the visible items.
      // The chainOffset is the position of the window in the full chain.
      var chainWindow = []
      var chainOffset = 0

      // Chain window length. Display this
      var N = 3

      // First
      si = new tapspace.SpaceImage(imgs[0], space)
      chainWindow.push(si)

      // Place other relative to the first.
      for (i = 1; i < N; i += 1) {
        si = new tapspace.SpaceImage(imgs[0], space)
        prev = chainWindow[i - 1]
        si.translateScaleRotate(
          [si.atNW(), si.atSE()],
          [prev.atNorm(B, B), prev.atNorm(A, A)]
        )
        chainWindow.push(si)
      }

      // Place heading on the first
      heading.setParent(space)
      heading.fitScale(chainWindow[0])

      // Center view to the beginning of the chain.
      view.fitScale(chainWindow[0]).scale(view.atMid(), PHI)

      // Instead of transforming the view, transform the items.
      // This way we can remove too big ones.
      var onTransform = function (itr) {
        var i, si
        var deltaOffset = 0

        // Transform
        for (i = 0; i < chainWindow.length; i += 1) {
          chainWindow[i].transformBy(itr)
        }

        // Transform also the heading if visible
        if (!heading.isRoot()) {
          heading.transformBy(itr)
        }

        var largest = chainWindow[0]
        var smallest = chainWindow[chainWindow.length - 1]
        var scale = largest.getLocalTransform().getScale()

        // If the largest is too large
        // it needs to be removed and a small created.
        if (scale > 20) {
          // Reuse the item
          chainWindow.push(chainWindow.shift())
          chainOffset += 1
          largest.translateScaleRotate(
            [largest.atNW(), largest.atSE()],
            [smallest.atNorm(B, B), smallest.atNorm(A, A)]
          )
          largest.bringToFront()

          // Hide heading if the first chain element was removed like this.
          if (chainOffset === 1) {
            heading.remove()
          }
        } // implicit else

        // If the largest is too small
        // a bigger one needs to be created.
        // The smallest can be removed.
        if (scale < 2 && chainOffset > 0) {
          // Reuse the item
          chainWindow.unshift(chainWindow.pop())
          chainOffset -= 1
          smallest.translateScaleRotate(
            [smallest.atNorm(B, B), smallest.atNorm(A, A)],
            [largest.atNW(), largest.atSE()]
          )
          smallest.sendToBack()

          // Render the heading for the first chain element.
          if (chainOffset === 0) {
            heading.setParent(space)
            heading.translateScaleRotate(
              [heading.atNW(), heading.atSE()],
              [smallest.atNW(), smallest.atSE()]
            )
          }
        }
      }

      var viewtouch = new tapspace.Touchable(view, view, onTransform)
      var viewwheel = new tapspace.Wheelable(view, view, onTransform)
      viewtouch.start({ translate: true, scale: true, rotate: true })
      viewwheel.start({ scale: true })
    })
  </script>
</body>
</html>
